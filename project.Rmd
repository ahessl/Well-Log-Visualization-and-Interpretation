---
title: "Project"
author: "Tobi Ore"
date: "12/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

## Objectives
The main objective of this project is to apply open source tools to carry out a basic petrophysical well log analysis. This involves transforming the well log measurements into reservoir properties like porosity, water saturation, clay content etc. The uptmost goal is to have as much information about the subsurface as possible.

## Data Source
The format of the data utilized for this project is the Log ASCII Standard (LAS). LAS is a standard file-format common in the oil-and-gas and water well industries to store well log information. This file type is like a typical text file, however, the formating is unique. 

Data of this nature is in abundance due to the high volume of oil and gas exploration. In this project, data from the Department of the Interior U.S. Geological Survey repository of Wildcat Wells in the National Petroleum Reserve in Alaska will be used (https://certmapper.cr.usgs.gov/data/PubArchives/OF00-200/WELLS/WELLIDX.HTM). However, this project is not exclusive to this data, therefore, the workflow and codes could be applied to data from other database.

The first challenge is loading this file type into the dataframe as base R doesn't have a built in function to properly recognize the LAS file and extract the well log readings without the metadata. A python package called lasio, as described below, would be used to load the data.

## Packages Used
This project utilizes the power of integrating Python and R because some packages required already exist in python.
`wget`, `bash`, `numpy`, `matplotlib`, `lasio` and `pandas`

## Data Downloading
Bash is used to automate the downloading of the well logs from the database. In the command line run `bash data_download.sh` to use the script. This well log data in LAS format is stored in a new folder called data in the working directory.

## Data loading
As previously explained, the well log data is in the LAS format. A custom made package called `lasio` is used to load the data into a single dataframe. A new column is created which corresponds to the well name from which the data is extracted from is created.

```{python}
# import required packages and libraries
import os
import lasio
import pandas as pd

#%% Data Loading
# load the well data into one DataFrame
data = pd.DataFrame()  #empty DataFrame to serve as container for the data

directory = r"C:\Users\Tobi\Documents\Open_Data_Science\Project\data"  #Directory containing the well data in .csv format

#loops through all the files in the directory, reads the csv and appends it to the data DataFrame
for file in os.listdir(directory):
    las = (lasio.read(os.path.join(directory, file)))  #load the LAS file
    well_data = las.df() #convert the LAS file to a panda DataFrame
    well_data['well_name'] = file[:-4]
    well_data['DEPTH'] = well_data.index
    well_data.rename_axis("DEPT", axis='index', inplace=True)  #rename the index M_DEPTH to DEPT
    data = data.append(well_data, sort=False,ignore_index=True)
```

To access the data in R, the following code chunk is used:
```{r}
data <- py$data
```

## Cross Match Tables
Cross match table is a 2D table (wells are in rows and logs are in columns) that shows the availability of logs for different wells. Cross match table could be useful to show if a specific log is available for a specific well (even if it is available only for a fraction of the measured depth). Cross match table could also be used to show the number of measurements of a specific log in a specific well. Number of measurements could also be presented in terms of percentage.

Three cross match table are created. Cross match table 1 is the count of valid well log measurements for each well and log, cross Match table 2 is the percentage of valid well log measurements (based on total length of well) and cross Match table 3 shows the availability of logs in the well by putting “X” where there is at least one measurement of the logs for each well in the dataset.

```{python}
#A table that shows the count of valid well log measurements for each wells
cross_match_1 = data.groupby('well_name').count()
cross_match_1.to_excel(r'cross_match_1.xls')

#A table that shows the percentage of valid well log measurements
cross_match_2 = cross_match_1.div(cross_match_1['DEPTH'], axis=0)*100
cross_match_2 = round(cross_match_2, ndigits=1)  #rounds the values to 1 decimal place
cross_match_2.to_excel(r'cross_match_2.xls')

#A table that puts "X" where there is at least one measurement of the logs for each well in the dataset
cross_match_3 = cross_match_2.replace(0,np.nan)
cross_match_3[cross_match_3>0] = 'X'
cross_match_3.to_excel(r'cross_match_3.xls')
```

## Data Visualization
The first step in petrophysical analysis is quick look interpretation. This is accomplished be visualizing the well logs and discerning some aparent informations/interpretation from the quick look.
To visualize the well logs, first, wells that have both Bit size and Caliper available are selected. This two logs are used for blow out identification. In the case of blow out, the well log readings are not reliable.
On the first track, the Bit Size and Caliper are both plot together. On track 2, Gamma ray and Spontaneous potential are plotted together. The resistivity logs (LL8, ILM and ILD) are  plot on the third track with a logarithmic x-axis.The density and neutron porosity is plot on the fourth and the sonic log on the fifth track.
```{python}
#check for wells with BS and CALI
well_BS_CALI = []
for well in cross_match_3.index:
    if cross_match_3.loc[well]['CALI'] == "X" and cross_match_3.loc[well]['BITSIZE'] == "X":
        well_BS_CALI.append(well)
#%%
###creates a folder to save the log images
###checks if a folder called Log_Images already exists to avoid error
if os.path.exists(os.path.join(os.path.split(directory)[0], "Log_Images")):
    pass
else:
    os.mkdir(os.path.join(os.path.split(directory)[0], "Log_Images")) 

#plot for each well
for well in well_BS_CALI:
    MD = data[data['well_name']==well]['DEPTH']
    BS = data[data['well_name']==well]['BITSIZE']
    CALI = data[data['well_name']==well]['CALI']
    GR = data[data['well_name']==well]['GR']
    SP = data[data['well_name']==well]['SP']
    RHOB = data[data['well_name']==well]['RHOB']
    NPHI = data[data['well_name']==well]['NPHI']
    LL8 = data[data['well_name']==well]['LL8']
    ILM = data[data['well_name']==well]['ILM']
    ILD= data[data['well_name']==well]['ILD']
    DT= data[data['well_name']==well]['DT']
    
    
    fig, ax = plt.subplots(nrows=1, ncols=5,figsize=(20,30), sharey=True)
    fig.suptitle("Well {} Log Display".format(well), fontsize=25)
    #fig.subplots_adjust(top=0.93)
    
    ax[0].invert_yaxis()
    ax[0].set_ylabel('MD (M)',fontsize=20)
    ax[0].yaxis.grid(True)
    
    ##Track 1
    ##Bit_size and Caliper
    ax_BS = ax[0].twiny()
    ax_BS.plot(BS,MD, color='brown')
    ax_BS.set_xlabel('BS (in)',color='brown',fontsize=15)
    ax_BS.tick_params('x',colors='brown')  ##change the color of the x-axis tick label
    ax_BS.set_xlim([5,25])

    ax_CALI = ax[0].twiny()
    ax_CALI.plot(CALI,MD, color='red',ls=':')
    ax_CALI.set_xlabel('CALI (in)',color='red',fontsize=15)
    ax_CALI.tick_params('x',colors='red')
    ax_CALI.set_xlim([5,25])
    ax_CALI.spines['top'].set_position(('outward',40)) ##move the x-axis up

    ax_BS.fill_betweenx(MD,BS,CALI, color='yellow')
    ax_BS.grid(True,alpha=0.5)

    ax[0].get_xaxis().set_visible(False) #removing the x-axis label at the bottom of the fig

    ##Track 2
    ##Gamma_ray and SP 
    ax_GR = ax[1].twiny()
    ax_GR.plot(GR,MD, color='black')
    ax_GR.set_xlabel('GR (API)',color='black',fontsize=15)
    ax_GR.tick_params('x',colors='black')  ##change the color of the x-axis tick label
    ax[1].get_xaxis().set_visible(False)
    ax[1].yaxis.grid(True)

    #ax_GR.fill_betweenx(MD,GR,75, where = GR>75, color='brown')
    #ax_GR.fill_betweenx(MD,GR,75, where = GR<75, color='yellow')
    ax_GR.grid(True,alpha=0.5)
    
    ax_SP = ax[1].twiny()
    ax_SP.plot(SP,MD, color='blue')
    ax_SP.set_xlabel('GR (API)',color='blue',fontsize=15)
    ax_SP.tick_params('x',colors='blue')  ##change the color of the x-axis tick label
    ax_SP.spines['top'].set_position(('outward',40)) ##move the x-axis up
    

    ##Track 3
    ##Resistivities
    ax_ILD = ax[2].twiny()
    ax_ILD.set_xlim(0.1,100)
    ax_ILD.set_xscale('log')
    ax_ILD.grid(True)
    ax_ILD.spines['top'].set_position(('outward',80))
    ax_ILD.set_xlabel('ILD[m.ohm]', color='red')
    ax_ILD.plot(ILD,MD, label='ILD[m.ohm]', color='red')
    ax_ILD.tick_params(axis='x', colors='red')    
    
    ax_ILM = ax[2].twiny()
    ax_ILM.set_xlim(0.1,100)
    ax_ILM.set_xscale('log')
    ax_ILM.plot(ILM, MD, label='ILM[m.ohm]', color='purple') 
    ax_ILM.spines['top'].set_position(('outward',40))
    ax_ILM.set_xlabel('ILM[m.ohm]', color='purple')    
    ax_ILM.tick_params(axis='x', colors='purple')
    
    ax_LL8 = ax[2].twiny()
    ax_LL8.set_xlim(0.1,100)
    ax_LL8.set_xscale('log')
    ax_LL8.plot(LL8,MD, '--',label='LL8[m.ohm]', color='black') 
    ax_LL8.spines['top'].set_position(('outward',0))
    ax_LL8.set_xlabel('LL8[m.ohm]',color='black')
    ax_LL8.tick_params(axis='x', colors='black')
    
    ax[2].get_xaxis().set_visible(False)
    ax[2].yaxis.grid(True)
    ax_LL8.grid(True,alpha=0.5)
    
    #Track 4
    ##NPHI and RHOB
    ax_NPHI = ax[3].twiny()
    ax_NPHI.set_xlim(40,-15)
    ax_NPHI.invert_xaxis()
    ax_NPHI.plot(NPHI, MD, label='NPHI[%]', color='green') 
    ax_NPHI.spines['top'].set_position(('outward',0))
    ax_NPHI.set_xlabel('NPHI[%]', color='green')    
    ax_NPHI.tick_params(axis='x', colors='green')
    
    ax_RHOB = ax[3].twiny()
    ax_RHOB.set_xlim(1.95,2.95)
    ax_RHOB.plot(RHOB, MD,label='RHOB[g/cc]', color='red') 
    ax_RHOB.spines['top'].set_position(('outward',40))
    ax_RHOB.set_xlabel('RHOB[g/cc]',color='red')
    ax_RHOB.tick_params(axis='x', colors='red')
    
    ax[3].get_xaxis().set_visible(False)
    ax[3].yaxis.grid(True)
    ax_RHOB.grid(True,alpha=0.5)
    
    #Track 5
    ##DT
    ax_DT = ax[4].twiny()
    ax_DT.grid(True)
    ax_DT.set_xlim(300,0)
    ax_DT.spines['top'].set_position(('outward',0))
    ax_DT.set_xlabel('DT[us/ft]')
    ax_DT.plot(DT, MD, label='DT[us/ft]', color='blue')
    ax_DT.set_xlabel('DT[us/ft]', color='blue')    
    ax_DT.tick_params(axis='x', colors='blue')
    
    ax[4].get_xaxis().set_visible(False)
    ax[4].yaxis.grid(True)
    ax_DT.grid(True,alpha=0.5)
    
    fig.savefig(r'{}\Log_Images\{}.png'.format(os.path.split(directory)[0], well, dpi=300))


```

## Some Petrophysical Calculations
__Volume of shale__

Volume of shale is the measure of the clay content of a rock. This is an important property when considering identification of reservoir rocks. The lower the volume the shale, the better the reservoir. There are numerous ways to estimate the volume of shale. The estimated values are then appended into the dataframe. The result is plotted and saved in a new folder called Vsh_images.

```{python}
#organize the data by wells in a dictionary
data_dict = {}
for well in well_BS_CALI:
    data_dict[well] = data[data['well_name']==well]

for well in well_BS_CALI:
    ##Volume of Shale
    data_dict[well]['VSH_linear'] = (data_dict[well]['GR'] - data_dict[well]['GR'].min())/(data_dict[well]['GR'].max() - data_dict[well]['GR'].min()) #Linear Gamma Ray
    data_dict[well]['VSH_larionov_young']=0.083*(2**(3.7*data_dict[well]['VSH_linear'])-1)   #Larionov (1969) - Tertiary rocks
    data_dict[well]['VSH_larionov_old']=0.33*(2**(2*data_dict[well]['VSH_linear'])-1)        #Larionov (1969) - Older rocks
    data_dict[well]['VSH_clavier']=1.7-(3.38-(data_dict[well]['VSH_linear']+0.7)**2)**0.5    #Clavier (1971)
    data_dict[well]['VSH_steiber']=0.5*data_dict[well]['VSH_linear']/(1.5-data_dict[well]['VSH_linear'])               #Steiber (1969) - Tertiary rocks
```

__Porosity estimation__

Porosity is the ratio of volume of void spaces to the total rock volume of the rock. This property describe the fluid retention ability of a rock and it is an important parameter when dealing with reservoir rocks. There are numerous techniques to estimate the porosity of a rock. The neutron-density approach will be used in this project. Assumptions will be made about the fluid type and matrix type to generalize the estimation for the whole well.

Density porosity is estimated by using `PHID = (RHOB - DENSma) / (DENSw - DENSma)` and the NPHI is the Neutron porosity.
The Neutron-Density Porosity is then estimated using the relationship below:
```
PHIND= (PHID + NPHI) / 2      #for interval without gas
PHIND= ((PHID**2+NPHI**2)/2)**(0.5)   #for interval with gas as seen from crossover
```
The result of this step is appended to the data as a new column called PHIND

## Spreadsheet containing new data
All the estimated values will be appended to the data and saved in a new text document named by the names of the well.


